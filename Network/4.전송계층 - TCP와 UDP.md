## TCP와 UDP의 목적과 특징
### 포트를 통한 프로세스 식별
IP주소와 MAC주소를 이용하면 패킷을 송수신하는 호스트를 특정할 수 있지만 실제로 패킷을 송수신하는 주체는 호스트의 **프로세스**입니다. 
웹 브라우저나 카카오톡 같은 프로세스는 **포트** 번호를 통해 식별할 수 있습니다. 즉 IP주소와 포트 번호의 조합으로 프로세스 식별이 가능합니다.

포트를 통한 프로세스 식별은 TCP, UDP 프로토콜이 속한 전송 계층의 주된 목적입니다. 그래서 TCP, UDP 헤더엔 송신지와 수신지 포트 번호가 포함되어 있습니다.

<img width="519" alt="image" src="https://github.com/user-attachments/assets/9729e5f4-cf89-46a0-b415-1a711a0e5da2" />

포트 번호는 16비트로 표현할 수 있기에 가능한 포트 번호는 총 65536개입니다. 포트 번호는 '잘 알려진 포트', '등록된 포트', '동적 포트'로 나뉩니다.

<img width="247" alt="image" src="https://github.com/user-attachments/assets/3200b117-293d-4072-bdcc-8f802c02d470" />

**잘 알려진 포트**는 아래와 같이 범용적으로 사용되는 프로토콜이 주로 사용하는 포트 번호들입니다. 예를 들어 SSH는 22, HTTP와 HTTPS는 80과 443을 사용합니다.

**등록된 포트**는 흔하게 사용되는 애플리케이션 프로토콜에 할당하는 포트 번호입니다.
우리가 Spring 프레임워크로 서버를 띄우면 8080 포트를, MySQL 서버는 3306 포트를 할당하는 것과 같습니다.

**동적 포트**는 사설 포트 또는 임시 포트라고도 불리며 웹 브라우저를 하나 열었을 때 임의의 포트 번호를 자유롭게 할당하는 것처럼 사용합니다.

포트 번호와 관련해 알아둘 지식은 **NAT(Network Address Translation)** 입니다.

어떤 네트워크 내부에 존재하는 호스트들은 공인 IP 주소가 아닌 사설 IP 주소를 할당 받습니다. 따라서 외부 호스트와 패킷을 주고 받기 위해서는 사설 IP 주소를 공인 IP 주소로 변환해야 합니다.

이 때, 서로 다른 사설 IP 주소가 같은 공인 IP 주소로 변환되더라도 포트 번호를 다르게 사용하면 네트워크 내부의 호스트를 특정할 수 있습니다. 
주소 변환 시 포트번호까지 고려하는 변환을 **NAPT(Network Address Port Translation)** 라고 합니다.

<img width="480" alt="스크린샷 2025-05-11 오후 10 32 04" src="https://github.com/user-attachments/assets/7b5f4765-0870-483d-9979-8385d2cfc89c" />

간단하게 "사설 IP 주소 : 포트번호"가 "공인 IP 주소 : 포트번호"로 대응되어 공유기(라우터)의 NAT 변환 테이블에 저장되어 있습니다.

따라서 외부 호스트(10.11.12.13)가 사설 IP 주소가 192.168.0.5:1025인 특정 호스트의 프로세스와 패킷을 주고 받기 위해서는 공인 IP 주소(1.2.3.4:6200)을 기반으로 통신하면 됩니다.

1.2.3.4:6200 IP주소가 헤더에 담긴 패킷을 전달받은 공유기(라우터)는 NAT 테이블을 참조해 대응되는 사설 IP 주소로 변환해 패킷을 처리합니다.

### (비)신뢰성과 (비)연결형 보장
TCP는 신뢰할 수 있는 연결형 송수신이 가능하고 UDP는 IP처럼 신뢰할 수 없는 비연결형 송수신이 가능합니다.

TCP는 패킷을 주고 받기 전에 연결 수립 과정을 거치며, 이후 신뢰성 보장을 위해 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 기능을 제공합니다. 반면 UDP는 이와 같은 기능을 제공하지 않습니다.
연결 수립 과정과 여러 기능을 제공하는 데에는 시간과 연산이 소요되기 때문에 일반적으로 UDP 송수신이 속도가 더 빠릅니다.

<img width="255" alt="image" src="https://github.com/user-attachments/assets/c0c0051d-466e-420c-93fa-deba3f0b0b5f" />
<img width="260" alt="image" src="https://github.com/user-attachments/assets/21fda50c-953f-4734-a6f5-ea991b2414bb" />

TCP와 UDP 헤더를 보면 송신지 포트와 수신지 포트가 명시됩니다. 체크섬은 데이터그램/세그먼트의 훼손 여부 정보가 명시됩니다.

TCP는 UDP에 비해 여러 기능을 제공하기 때문에 헤더 필드의 숫자도 훨씬 많습니다. 이중 **순서번호, 확인 응답 번호, 제어 비트 중 ACK, SYN, FIN 플래그**는 반드시 알아야 합니다.

**순서 번호**란, TCP 패킷(세그먼트)의 올바른 송수신 순서를 보장하기 위해 세그먼트의 첫 바이트에 매겨진 번호입니다. 말 그대로 세그먼트가 몇 번째 세그먼트인지 표기합니다.

**확인 응답 번호**란, 상대 호스트가 보낸 세그먼트에 대한 응답으로 다음으로 수신하길 기대하는 세그먼트의 순서 번호입니다. 보통 순서 번호에 1이 더해진 값으로 설정됩니다.

<img width="269" alt="image" src="https://github.com/user-attachments/assets/84cb6964-37dd-4c6f-bb5b-13de562f27c1" />

예를 들어, 순서 번호 100인 세그먼트를 받았다면 응답 번호 101인 세그먼트를 응답으로 전송합니다.
이 때, B는 A에게 세그먼트가 확인 응답 번호를 포함하고 있음을 알리기 위해 ACK 플래그를 1로 설정합니다.

제어 비트 중 ACK 플래그 말고 SYN 플래그는 연결을 수립하기 위한 비트, FIN은 연결을 종료하기 위한 비트입니다.

## TCP의 연결부터 종료까지
### TCP의 연결 수립
TCP는 연결형 송수신 프로토콜이기 때문에 연결 수립 과정이 선행되어야 합니다. 이는 **3-way handshake** 과정을 통해 이루어집니다.
이름처럼 3단계로 이루어진 과정입니다.
1. [A->B] SYN 세그먼트 전송
   
   A는 B에게 SYN 비트가 1로 설정된 세그먼트를 전송합니다.
   
2. [B->A] SYN + ACK 세그먼트 전송
   
   B는 A에게 SYN 비트와 ACK 비트가 1인 세그먼트를 전송합니다.
   
3. [A->B] ACK 세그먼트 전송
   
   A는 B에게 ACK 비트가 1로 설정된 세그먼트를 전송합니다.

위의 과정에서 순서 번호와 응답 번호는 이전 세그먼트를 기반으로 설정됩니다.
3-way handshake에서 SYN 비트가 설정된 패킷을 처음으로 보내 연결을 시작하는 과정을 **액티브 오픈**이라고 하고, 반대로 그에 대한 연결을 수립하는 과정을 **패시브 오픈**이라고 합니다.

<img width="316" alt="스크린샷 2025-05-11 오후 11 01 56" src="https://github.com/user-attachments/assets/772f7c42-cb83-4c06-8d45-587d88c0957a" />

### TCP의 오류, 흐름, 혼잡 제어
TCP는 패킷의 신뢰성 보장을 위해 오류, 흐름, 혼잡 제어 3가지 기능을 제공합니다.
1. 재전송을 통한 오류 제어
   
   TCP는 잘못 전송된 세그먼트가 있을 경우, 이를 재전송하여 오류를 제어합니다. 잘못 전송된 세그먼트가 있는 경우는 크게 2가지 상황이 있습니다.
   하나는 중복된 ACK가 도착했을 때이고, 하나는 타임아웃이 발생했을 때입니다.
   TCP 송수신은 기본적으로 세그먼트를 보내고 재전송 타이머라는 값을 유지하고 타이머 카운트 다운이 끝나기 전에 ACK 세그먼트를 받아야 정상적인 상황입니다.
   
   <img width="263" alt="image" src="https://github.com/user-attachments/assets/df2f8fa5-31cc-4f38-97c6-c2b480c17a9a" />
   <img width="293" alt="image" src="https://github.com/user-attachments/assets/95671201-40b7-45b3-9626-fe5cd7afa86f" />
   
   왼쪽은 n+1번째 세그먼트가 손실되면 호스트 B 입장에선 타임아웃 전에 세그먼트를 받지 못했기 때문에 ACK 세그먼트를 재전송합니다.
   
   오른쪽은 호스트 A가 n+1번째 세그먼트를 보냈으나 손실되어 타임아웃 전에 ACK 세그먼트를 받지 못했기 때문에 n+1번째 세그먼트를 재전송합니다.

   기본적으로 세그먼트를 보내고 ACK 세그먼트를 받고 그 다음 세그먼트를 순차적으로 보내지만 성능 향상을 위해 여러 세그먼트를 한 번에 보내는 **파이프라이닝 전송**을 합니다.

   <img width="306" alt="image" src="https://github.com/user-attachments/assets/42ba15b6-d413-4a62-85a7-018644f52a2b" />

3. 흐름 제어
   
   수신 호스트가 한 번에 n개의 바이트까지 처리할 수 있다면 송신 호스트는 n개의 바이트를 넘지 않는 선에서 송신해야 합니다. 이런 흐름 제어는 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능입니다.
   이렇게 수신 호스트가 한 번에 처리할 수 있는 양을 **수신 윈도우**라고 합니다. 수신 윈도우 값은 TCP 헤더의 윈도우 필드에 명시되어 있습니다.
  
4. 혼잡 제어
   
   많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실되는 상황을 제어하는 기능입니다.
   송신 호스트가 주체적으로 얼마나 네트워크가 혼잡한지를 판단할 수 있어야 하고 혼잡 정도에 따라 세그먼트의 전송량을 조절해야 합니다.
   네트워크의 혼잡 정도는 중복된 ACK 세그먼트가 도착했을 때, 타임아웃이 발생했을 때를 기준으로 판단합니다.
   혼잡 정도를 판단한 송신 호스트는 '혼잡 없이 전송할 수 있을 정도의 양'인 **혼잡 윈도우** 값만큼만 송신합니다.

   수신 윈도우는 헤더에 포함되어 있지만 혼잡 윈도우는 어떻게 알 수 있을까요?
   
   혼잡 제어 알고리즘인 **AIMD(Additive Increase/Mutiplicative Decrease)** 를 이용합니다.
   AIMD는 패킷을 보내고 응답이 수신되기까지 시간인 RTT마다 혼잡이 감지되지 않으면 혼잡 위도우를 1 증가시키고 혼잡이 감지되면 절반으로 떨어뜨립니다.

### TCP의 종료
TCP의 연결 종료는 FIN과 ACK를 주고받으며 이루어집니다.
1. [A->B] FIN 세그먼트
   
   FIN 비트가 1로 설정된 세그먼트를 전송합니다.
   
2. [B->A] ACK 세그먼트

   ACK 비트가 1로 설정된 세그먼트를 전송합니다.
   
3. [B->A] FIN 세그먼트

   FIN 비트가 1로 설정된 세그먼트를 전송합니다.
  
4. [A->B] ACK 세그먼트
   
   ACK 비트가 1로 설정된 세그먼트를 전송합니다.
   
연결 수립 과정과 유사하게 먼저 연결을 종료하는 동작을 **액티브 클로즈**, 연결 종료 요청을 받아들이는 동작을 **패시브 클로즈**라고 합니다.

<img width="346" alt="스크린샷 2025-05-11 오후 11 02 11" src="https://github.com/user-attachments/assets/a95c2dd5-22b2-4bae-8e2d-6ba414c591d6" />

## TCP의 상태 관리
TCP의 또 다른 중요한 특징은 상태를 유지하는 **StateFul**한 프로토콜이라는 것입니다. 여기서 상태란, 어떤 통신 과정에 있는 지를 나타내는 정보입니다.
TCP의 상태는 각종 네트워크 명령어로 찾아볼 수 있습니다. 상태 정보를 토대로 송수신 현황을 판단하거나 디버깅 힌트로도 사용합니다.

<img width="434" alt="image" src="https://github.com/user-attachments/assets/3a5be5f3-92c5-4109-a5f6-ef15f0de6250" />

상태가 많은데 크게 3가지로 분류합니다.

1. 연결이 수립되지 않았을 때 주로 활용되는 상태

   <img width="504" alt="image" src="https://github.com/user-attachments/assets/06bfff35-f772-41fc-9723-e7045148be55" />
   
2. 연결 수립 과정에서 주로 활용되는 상태

   <img width="503" alt="image" src="https://github.com/user-attachments/assets/45528b6f-21a0-46df-9855-db44050946b0" />
   <img width="382" alt="스크린샷 2025-05-11 오후 11 04 34" src="https://github.com/user-attachments/assets/2988963c-25b3-422d-9013-2a0bd432eef0" />
   
3. 연결 종료 과정에서 주로 활용되는 상태

   <img width="513" alt="image" src="https://github.com/user-attachments/assets/7bee30a6-70d0-4514-97f2-9dc110ccc68b" />
   <img width="373" alt="image" src="https://github.com/user-attachments/assets/98510508-e02c-41b7-8ac6-eeb7093cdbe0" />

# 목차
- [학습 내용](#학습-내용)
  - [CPU 스케줄링이란?](#cpu-스케줄링이란)
  - [우선순위](#우선순위)
  - [우선순위 산정 방식](#우선순위-산정-방식)
  - [스케줄링 큐](#스케줄링-큐)
  - [리눅스 스케줄링 정책](#리눅스-스케줄링-정책)
- [핵심 키워드 정리](#핵심-키워드-정리)

# 학습 내용

### CPU 스케줄링이란?
> 프로세스와 스레드가 자원을 어떻게 할당받을까?
+ 운영체제는 운영중인 프로세스와 스레드에 자원을 분배한다.
+ 여기서 CPU 자원을 분배하는 방법을 CPU 스케줄링이라고 한다.

### 우선순위
> 모든 프로세스가 공평하게 CPU 자원을 할당 받지는 않는다.
+ 운영체제는 프로세스 별로 우선순위를 판단하는데, 이 우선순위를 PCB(Process Control Block)에 명시해둔다.
+ 우선순위가 높은 프로세스일수록 CPU 자원을 빠르고, 많이 할당 받을 수 있다.
+ 운영체제는 실행중인 프로세스들의 우선순위를 확인할 수 있는 방법을 제공하는데, 리눅스 기반의 OS에서 사용되는 ps 명령어가 그 예이다.

### 우선순위 산정 방식
> 그렇다면 운영체제는 어떤 기준으로 프로세스 별 우선순위를 정할까?
+ 고려 요소는 많지만, 기본 원칙은 **CPU 활용율을 높게 만들도록/유지하도록 우선순위를 산정한다.**
+ 입출력 작업이 많은 프로세스(입출력 집중 프로세스)의 우선순위를 높게 산정하는데, 입출력 작업은 대기시간이 있기 때문이다.
+ 입출력 집중 프로세스가 대기하는 시간이 많으므로 빠르게 대기 상태로 들어가도록 두고, CPU 집중 프로세스가 계속해서 자원을 사용할 수 있도록 하는 것이다.

### 스케줄링 큐
> 자원을 할당받지 못하고 있는 프로세스는 그럼 어떻게 될까?
+ 자원을 당장 이용 불가능할 경우(다른 프로세스가 점유 중인 경우), 스케줄링 큐라는 특별한 큐에 프로세스 자신의 PCB를 추가해야 한다.
+ 여기서 자원이란 얘기 중이었던 CPU 뿐만이 아닌 메모리, 입출력 장치 등등 모든 리소스에 적용된다.

> 자원을 사용중일 때, 우선순위가 더 높은 프로세스가 자원을 요청하면 어떻게 돼?
+ 자원을 점유중인 프로세스보다 우선순위가 더 높은 프로세스가 자원을 요청한다면, **스케줄링 방식에 따라 결과가 나뉜다.**
+ 선점형(Preemptive) 스케줄링의 경우:
  + 현재 자원을 사용 중인 낮은 우선순위 프로세스로부터 자원을 강제로 빼앗을 수 있다.
  + 이 경우, 낮은 우선순위 프로세스는 일시 중단되고 그 PCB가 스케줄링 큐에 들어가게 된다.
+ 비선점형(Non-preemptive) 스케줄링의 경우:
  + 현재 자원을 사용 중인 프로세스가 자원을 자발적으로 반환할 때까지 우선순위가 높은 프로세스도 기다려야 함.
  + 따라서 우선순위가 높더라도 이미 실행 중인 프로세스는 중단시킬 수 없음.

> 그러면 스케줄링 큐는 무조건 선입선출(FIFO)일까?
+ 스케줄링 큐가 무조건 선입선출(FIFO) 방식으로만 동작하는 것은 아님. **운영체제는 다양한 스케줄링 알고리즘을 사용하며, 각 알고리즘마다 큐의 구조와 운영 방식이 다르다.**
+ FIFO/FCFS(First-Come, First-Served): 가장 단순한 형태로, 도착한 순서대로 프로세스를 실행함.
+ 우선순위 큐(Priority Queue): 프로세스의 우선순위에 따라 정렬된다. 우선순위가 높은 프로세스가 먼저 실행함.
+ 다단계 큐(Multilevel Queue): 여러 개의 큐를 사용하여 다른 우선순위 또는 특성을 가진 프로세스들을 서로 다른 큐에 배치함.
+ 다단계 피드백 큐(Multilevel Feedback Queue): 여러 개의 큐를 사용하면서, 프로세스의 동작 패턴에 따라 프로세스가 다른 큐로 이동할 수 있음.
+ 라운드 로빈(Round Robin): FIFO 방식이지만 각 프로세스는 정해진 시간(타임 퀀텀) 동안만 실행되고, 이후 큐의 뒤로 이동함.
+ SJF(Shortest Job First): 실행 시간이 가장 짧은 프로세스를 먼저 실행함.
+ SRTF(Shortest Remaining Time First): 남은 실행 시간이 가장 짧은 프로세스를 먼저 실행함.

### 리눅스 스케줄링 정책
> 리눅스에서는 프로세스의 성질에 따라 각각 다른 스케줄링 정책을 적용함.
* **SCHED_OTHER (또는 SCHED_NORMAL)**:
   * 일반적인 프로세스용 기본 스케줄링 정책임.
   * CFS(Completely Fair Scheduler)가 이 클래스를 처리함.
   * 가장 낮은 우선순위를 가짐.
   * 일반적인 사용자 애플리케이션에 사용됨.

* **SCHED_BATCH**:
   * CPU 집약적이지만 대화형이 아닌 배치 프로세스용임.
   * CFS로 관리되나 대화형 작업보다 낮은 우선순위가 부여됨.
   * 백그라운드 작업, 계산 집약적 작업에 적합함.

* **SCHED_IDLE**:
   * 매우 낮은 우선순위의 백그라운드 작업용임.
   * 시스템에 다른 작업이 없을 때만 실행됨.
   * CFS로 관리되나 가장 낮은 우선순위를 가짐.
   * 시스템 유휴 시간에만 수행할 작업에 적합함.

* **SCHED_FIFO**:
   * 실시간 FIFO(First-In-First-Out) 정책임.
   * 선점 없이 완료될 때까지 또는 자발적으로 양보할 때까지 실행됨.
   * 실시간 우선순위를 가짐.
   * 즉각적인 응답이 필요한 작업에 적합함.

* **SCHED_RR**:
   * 실시간 라운드 로빈 정책임.
   * SCHED_FIFO와 유사하나 시간 할당량이 적용됨.
   * 실시간 우선순위를 가짐.
   * 여러 실시간 작업 간에 CPU 시간을 공유해야 할 때 유용함.

* **SCHED_DEADLINE**:
   * 최신 추가된 스케줄링 정책임.
   * 최종 마감시간 보장이 필요한 작업용임.
   * 가장 높은 우선순위를 가짐.
   * 주기적인 실시간 작업에 적합함.
---

# 핵심 키워드 정리
### CPU 스케줄링 관련
- **CPU 스케줄링**: 운영체제가 프로세스와 스레드에 CPU 자원을 분배하는 방법
- **우선순위**: 프로세스별로 CPU 자원 할당의 순서와 양을 결정하는 값
- **PCB (Process Control Block)**: 프로세스의 정보와 우선순위를 저장하는 자료구조
- **입출력 집중 프로세스**: 입출력 작업이 많은 프로세스로, 일반적으로 우선순위가
- **CPU 집중 프로세스**: CPU 연산이 많은 프로세스

### 스케줄링 알고리즘 관련
- **선점형 스케줄링**: 우선순위가 높은 프로세스가 실행 중인 프로세스의 자원을 빼앗을 수 있는 방식
- **비선점형 스케줄링**: 실행 중인 프로세스가 자발적으로 자원을 반환할 때까지 기다리는 방식
- **FIFO/FCFS**: 먼저 도착한 프로세스를 먼저 실행하는 방식
- **우선순위 큐**: 우선순위에 따라 프로세스를 정렬하는 큐
- **다단계 큐/다단계 피드백 큐**: 여러 우선순위 큐를 사용하는 스케줄링 방식
- **라운드 로빈**: 정해진 시간(타임 퀀텀)만큼만 실행 후 큐의 뒤로 이동하는 방식
- **SJF/SRTF**: 실행 시간이 짧은 프로세스를 우선하는 방식

### 리눅스 스케줄링 정책 관련
- **CFS (Completely Fair Scheduler)**: 리눅스의 기본 스케줄러
- **SCHED_NORMAL/OTHER**: 일반 프로세스용 기본 스케줄링 정책 -> CFS 사용
- **SCHED_BATCH**: CPU 집약적인 비대화형 프로세스용 정책
- **SCHED_IDLE**: 매우 낮은 우선순위의 백그라운드 작업용 정책
- **SCHED_FIFO**: 실시간 선입선출 정책
- **SCHED_RR**: 실시간 라운드 로빈 정책
- **SCHED_DEADLINE**: 마감시간 보장이 필요한 작업용 정책



---

# 나왔던 질문

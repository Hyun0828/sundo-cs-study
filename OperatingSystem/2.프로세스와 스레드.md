## 1. 프로세스 
### (1) 프로세스 유형
- 포그라운드 프로세스 (Foreground Process): 사용자가 직접 조작하고 볼 수 있는 프로세스입니다.  
  - 예: 크롬 브라우저, 메모장, 게임 등
- 백그라운드 프로세스 (Background Process): 사용자와 상호작용 없이 보이지 않는 곳에서 실행되는 프로세스입니다.  
  - 예: 윈도우 업데이트, 바이러스 검사 프로그램 등
  - 데몬 (Daemon) : 백그라운드에서 실행되며, 시스템의 필수적인 작업을 자동으로 처리하는 프로세스입니다. 일반적으로 사용자와의 상호작용 없이 실행되며, 윈도우에서는 **서비스**라고 불립니다.

### (2) 프로세스 메모리 구조
<img width="423" alt="스크린샷 2025-04-13 오후 9 20 12" src="https://github.com/user-attachments/assets/b2faeee9-cca6-4516-b42a-a17ac33cd9d8" />

사진 출처 : 이것이 취업을 위한 컴퓨터 과학이다 with cs 기술 면접

프로세스가 메모리에 적재되는 구조는 유형에 관계없이 유사합니다. 프로세스는 **커널 영역**과 **사용자 영역**으로 나뉘며, 사용자 영역은 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉩니다.

#### 메모리 영역 설명:
1. 코드 영역 (Code Segment)
   - 실행 가능한 명령어가 저장되는 공간으로, CPU가 읽고 실행할 명령어를 저장합니다. 읽기 전용이며, 텍스트 영역이라고도 불립니다.
   - 사용자에게 보여지는 virtual memory에서 하위메모리 공간에 할당됩니다.
3. 데이터 영역 (Data Segment)
   - 프로그램 실행 동안 유지할 데이터를 저장하는 공간입니다. 초깃값이 있는 데이터가 여기에 저장됩니다.
   (+) BSS 영역: 초깃값이 없는 데이터가 저장됩니다.
5. 힙 영역 (Heap Segment)
   - 사용자가 직접 할당하고 해제하는 동적 메모리 공간입니다.
   
   -> 메모리 누수 : 메모리 공간을 반환하지 않으면 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비한다. 런타임에 실제 사용량이 결정되며, 지나치게 많은 메모리가 사용될 경우, 프로세스가 메모리 부족으로 비정상 종료됩니다.

   -> 가비지 컬렉션 : 프로그래밍 언어에서 자체적으로 사용하지 않는 힙 메모리를 해제합니다.
7. 스택 영역 (Stack Segment): 함수 호출 시 일시적으로 사용하는 데이터가 저장되는 공간입니다. 함수가 호출될 때마다 데이터를 저장하고, 함수 종료 시 해당 데이터를 제거합니다.
   - 스택 트레이스 : 특정 시점에 스택 영역에 저장된 함수 호출 정보

### (3) PCB와 문맥 교환
<img width="131" alt="스크린샷 2025-04-13 오후 9 44 15" src="https://github.com/user-attachments/assets/88187ce5-cd41-4ec7-af92-bbfb2759b60a" />

#### PCB (Process Control Block)

- 운영체제가 프로세스를 관리하기 위해 사용하는 자료구조입니다.  
- 프로세스가 생성될 때 **커널 영역**에 생성되며, 프로세스 종료 시 폐기됩니다.  
- 프로세스의 식별자, 상태, 프로그램 카운터, CPU 스케줄링(우선순위) 정보 등 다양한 정보가 저장됩니다.

#### 문맥 교환 (Context Switching)

- 하나의 프로세스가 CPU를 사용하다가 **상태가 전이**되면, 현재 작업 내용을 PCB에 저장(백업)하고 CPU를 반환해야 합니다.
- 이후 CPU를 다시 점유할 때, PCB에 저장된 정보(문맥)를 복원하여 이전 작업을 이어서 수행할 수 있습니다.
- 이 과정이 바로 **문맥 교환**입니다.

> 좀비 프로세스 : 비정상 종료되어 사용한 자원이 회수되었음에도 프로세스 테이블에 종료된 프로세스의 PCB가 남아있는 비정상 종료 상태를 의미한다.

> 프로세스의 CPU 점유 시간은 일정 시간마다 발생하는 **타이머 인터럽트**에 의해 제한됩니다.

#### 문맥 교환의 단점
- 문맥 교환이 잦을수록 캐시 미스가 자주 발생할 수 있습니다.  
- 이로 인해 메모리 접근 횟수가 증가하고, 오버헤드가 커지게 됩니다.  
- 따라서 운영체제는 문맥 교환의 빈도와 효율을 고려해 스케줄링을 수행합니다.

### (4) 프로세스 상태
<img width="514" alt="스크린샷 2025-04-13 오후 11 13 19" src="https://github.com/user-attachments/assets/4bf16257-8152-46a3-a46b-09abdcd38e9e" />

사진 출처 : itwiki.kr

- 생성 상태 (new) : 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태입니다.
- 준비 상태 (ready) : CPU를 할당받아 실행할 수 있지만 기다리고 있는 상태입니다.
- 실행 상태 (running) : CPU를 할당받아 실행 중인 상태입니다.
- 대기 상태 (blocked) :입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 등 바로 실행이 불가능한 조건에 놓인 상태입니다.
- 종료 상태 (terminated) : 프로세스가 종료된 상태로, 운영체제가 PCB와 프로세스가 사용한 메모리를 정리합니다.

<br>

## 2. 멀티 프로세스와 멀티 스레드
### (1) 블로킹 입출력과 논블로킹 입출력
입출력 작업 중 프로세스가 어떻게 동작하는지에 따라 다음과 같이 나뉩니다.
- 블로킹 입출력 : 입출력 작업이 끝날 때까지 프로세스는 대기 상태로 전환되며, 완료 후 다시 실행됩니다.
- 논블로킹 입출력 : 입출력 작업을 요청한 후에도 프로세스는 대기하지 않고 다음 명령을 계속 실행합니다.

### (2) 멀티 프로세스
- 여러 개의 프로세스가 동시에 실행됩니다.
- **자원을 공유하지 않으며**, 독립적으로 동작합니다.
- 각각의 프로세스는 고유의 PID를 가지며, 파일, 메모리, 입출력 장치 등도 분리되어 있어 서로 간섭하지 않습니다.

### (3) 차이점
<img width="744" alt="스크린샷 2025-04-13 오후 11 29 39" src="https://github.com/user-attachments/assets/dafd645d-5ddb-40de-9f0c-dd8cbc950b70" />

사진 출처 : https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-multi-process-multi-thread

| 구분            | 멀티 프로세스                         | 멀티 스레드                          |
|-----------------|----------------------------------------|---------------------------------------|
| 자원 공유   | 자원을 공유하지 않음                  | 메모리, 파일 등을 공유함              |
| 독립성       | 각 프로세스는 독립적으로 실행됨       | 스레드는 하나의 프로세스 내부에서 실행됨 |
| 오버헤드     | 프로세스 생성 비용이 큼                | 스레드는 생성과 전환 비용이 적음       |
| 안정성       | 하나가 죽어도 다른 프로세스에 영향 없음 | 하나의 스레드 오류가 전체에 영향을 줄 수 있음 |

<br>

## 3. 프로세스 간 통신 (IPC, inter-process Communicatioin)
운영체제에서 각 프로세스는 독립된 메모리 공간을 사용하므로, 데이터를 직접 주고받을 수 없습니다. 이를 해결하기 위해 **IPC(Inter-Process Communication)** 기법이 사용되며, 대표적으로 **공유 메모리 방식**과 **메시지 전달 방식**이 있습니다.

### (1) 공유 메모리
- 둘 이상의 프로세스가 공통된 메모리 영역을 공유하여 데이터를 주고받는 방식입니다.
- 커널 개입이 거의 없어 속도가 빠릅니다.
- 각 프로세스는 공유된 메모리 공간에 접근하여 마치 자신의 메모리처럼 데이터를 읽고 씁니다.
- 별도의 동기화 조치가 없을 경우, **경쟁 상태(Race Condition)**가 발생할 수 있습니다.

### (2) 메시지 전달
- 커널을 통해 프로세스 간 데이터를 송수신하는 방식입니다.
- 송신자와 수신자가 명확히 구분되며, 동기화와 오류 제어가 용이합니다.
- 속도는 공유 메모리보다 느리지만 안정적입니다.
- 대표적인 메시지 전달 방식:
   - 파이프 (Pipe)
   - 시그널 (Signal)
   - 소켓 (Socket)
   - 원격 프로시저 호출 (RPC)

#### 파이프
단방향 프로세스간의 통신 도구입니다.
- 익명 파이프 : 양방향 지원하지 않고, 부모 프로세스와 자식 프로세스 간에만 통신이 가능합니다.
- 지명 파이프 : 익명 파이프를 확장한 파이프로, 양방향 통신을 지원하고 임의의 프로세스 간에도 통신이 가능합니다.
#### 시그널 
<img width="511" alt="스크린샷 2025-04-13 오후 11 51 48" src="https://github.com/user-attachments/assets/ee3998ea-cffe-437e-b14a-77403662ae70" />

- 비동기 이벤트를 알리기 위한 신호입니다.
- IPC만을 위한 기술은 아니며, 프로세스 상태 변화를 알릴 때도 사용됩니다.
- 시그널이 발생하면, 시그널 핸들러가 실행된 후 원래 실행을 재개합니다.
-> 프로세스를 종료하거나 무시하거나 코어 덤프를 생성합니다.
-> 코어 덤프 (Core Dump) : 프로그램이 비정상적으로 종료되었을 때, 당시의 메모리 상태, 레지스터 값, 호출 스택 정보 등을 저장한 파일입니다. 주로 디버깅을 위해 사용됩니다.

```
$ python3 coredumped.py
Segmentation fault (core dumped)
```

#### 원격 프로시저 호출 (RPC)
- 네트워크 상의 다른 컴퓨터에 있는 함수(프로시저)를 마치 로컬 함수처럼 호출할 수 있는 방식입니다.
- 클라이언트가 함수를 호출하면, 그 요청은 서버로 전송되고, 서버는 처리 결과를 다시 클라이언트에 전달합니다.
- 네트워크 통신의 복잡함을 숨기고, 함수 호출 방식처럼 쉽게 분산 시스템을 구현할 수 있게 도와줍니다.

## 1. DNS 와 URI/URL
도메인 네임: 문자열 형태의 호스트 특정 정보로, 호스트의 IP 주소와 대응됩니다. <br>
-> IP 주소가 바뀌더라도 바뀐 IP 주소에 도메인 네임을 다시 대응하면 되므로 IP주소만으로 호스트를 특정하는 것보다 간편합니다.

네임 서버라는 특별한 서버에서 도메인 네임과 IP주소를 관리하고, 도메인 네임을 관리하는 네임 서버를 DNS 서버라고 부릅니다.

리졸빙 (resolving) : IP주소를 모르는 상태에서 도메인 네임에 대응되는 IP주소를 알아내는 과정을 의미합니다.

### 도메인 네임 
도메인은 계층적 구조를 가지고 있습니다.

<img width="706" alt="스크린샷 2025-05-13 오후 9 24 46" src="https://github.com/user-attachments/assets/7ee99db4-7b1f-4063-8b1b-03c6ddbb9632" />

FQDN(전체주소도메인 네임) : 도메인 네임을 모두 포함하는 도메인 네임입니다. <br>
-> 호스트를 식별할 수 있습니다.


### DNS
: 계층적 형태로 이뤄진 도메인 네임을 관리하는 네임 서버 또한 계층적으로 이루어져서 전 세계에 분산되어 관리됩니다. 이러한 도메인 네임에 대한 관리 체계입니다.

로컬 네임 서버 : 클라이언트와 맞닿아 있는 네임 서버로, 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버입니다. <br>
ISP가 로컬 네임 서버의 주소를 자동으로 할당햅니다. 다만, ISP에서 할당해주는 로컬 네임 서버 주소가 아닌 공개 DNS 서버 를 이용할 수도 있습니다.  <br>
(대표적인 예로는 구글의 '8.8.8.8.8.8.4.4' 또는 클라우드플레어의 '1.1.1.1'이 있습니다.) 

1-1. 로컬 네임 서버가 FQND에 대응하는 IP주소를 알고 있다면 클라이언트에게 즉시 해당 IP주소를 반환합니다. <br>
1-2. 만약 모른다면 로컬네임서버는 FQND에 대응하는 IP주소를 알아낼 때까지 도메인 네임의 루트 도메인을 관장하는 서버(루트네임서버)에게 질의하고, 최상위 도메인을 관장하는 서버(TLD 네임 서버), 그 하위 레벨의 도메인 네임을 관장하는ㄴ 네이임 서버 등에 걸쳐 질의하게 됩니다. <br>
2. 최종적으로 클라이언트가 원하는 IP주소를 반환받으면 해당 주소를 클라이언트에게 전달합니다.

-> 이러한 질의 과정이 너무 많이 반복되면 네트워크 내 트래픽이 많아지고, 리졸빙에 지나치게 오랜 시간일 걸리기 때문에  <br>
-> DNS캐시 : 실제로는 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 동일한 질의에 활용하는 경우가 많습니다.


### 자원과 URI/URL
자원 : 네트워크 상의 메시지를 통해 주고받는 최종 대상을 의미합니다.<br>
(예: 이미지, 동영상 파일, 텍스트 파일 등)

URI(identifier) : 웹 상에서의 자원을 식별하기 위한 정보를 의미합니다.<br> = URN + URL
자원을 식별하는 통일된 방식으로 자원을 식별할 때는 이름(URN name)을 기반으로 식별하기도 하고, 위치(URL locator)를 기반으로 식별하기도 합니다.

### URL
<img width="701" alt="스크린샷 2025-05-13 오후 9 37 18" src="https://github.com/user-attachments/assets/4c0a92f5-aefd-4c70-9669-db05ab2a99a2" />

(1) scheme : 자원에 접근하는 방법을 의미합니다.<br>
(2) authority : 호스트를 특정할 수 있는 IP 주소나 도메인 네임이 명시됩니다. 클론(:) 뒤에 포트번호를 명시할 수도 있습니다.<br>
(3) path : 자원이 위치하고 있는 경로가 명시됩니다. 슬래시(/)를 기준으로 계층적으로 표현되며, 최상위 경로 또한 슬래시로 표현됩니다.<br>
(4) query : URL에 대한 매개변수 역할을 하는 문자열입니다. (= 쿼리 문자열, 쿼리 파라미터) <br>
-> 특정 단어를 검색한 결과에 해당하는 장원 등 추가적인 정보를 필요할 때 사용합니다.<br>
(5) fragment : 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보입니다. HTML 파일과 같은 자원에서 특정 부분을 가리키는데 사용됩니다.


## 2. HTTP의 특징과 메시지 구조
- HTTP의 목적 : 애플리케이션의 다양한 자원을 네트워크를 통해 송수신하는 것입니다.

 
### HTTP의 특징
(1) 요청 응답 기반 프로토콜<br>
(2) 미디어 독립적 프로토콜 <br>
: 다양한 종류의 자원을 주고 받을 수 있습니다. 

미디어 타입 : HTTP에서 메시지로 주고 받는 자원의 종류을 의미합니다.<br>
보통 타입(데이터유형)/서브타입(주어진 타입에 대한 세부 유형) 형식으로 구성됩니다. 
```
// 미디어타입 예시
text/html;charset=utf-8
application/json(기본이 utf-8)
image/png
```

(3) stateless 프로토콜
상태를 유지하지 않는 프로토콜로, 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않습니다.<br>
-> 클라이언트의 모든 HTTP 요청은 기본적으로 독립된 요청으로 간주됩니다.

많은 클라이언트와 동시에 상호작용하기 때문에 동시에 처리해야 할 요청 메시지의 수가 수천개 수백만개가 될 수도 있기 때문에,<br>
이러한 상황에서 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이 됩니다.<br>
또한 서버가 여러 대로 구성될 수도 있는데, 여러 대로 구성된 서버 모두가 모든 클라이언트의 상태를 유지해야 한다면 모든 서버가 모든 클라이언트의 상태 정보를 공유해야 하는 상황이 발생하기 때문입니다.<br>

HTTP 서버가 지켜야 할 중요한 설계 목표에는 확장성과 견고성이 있습니다.<br>
상태를 유지하지 않고 모든 요청을 독립적으로 처리하면 특정 클라이언트가 특정 서버에 종속되지 않습니다.<br>
따라서 서버의 추가나 대체가 쉬워집니다.

(4) 지속 연결 프로토콜<br>
HTTP/1.1부터 기본적으로 지속 연결을 지원합니다.

하나의 TCP 연결을 통해 여러 개의 요청/응답을 처리할 수 있습니다.<br>
(즉, 매 요청마다 TCP 연결을 새로 열지 않아도 됨 → 성능 개선)

연결 종료는 `Connection: close` 헤더를 통해 명시적으로 요청해야 합니다.


| HTTP 버전   | 전송 계층 | 설명 |
|-------------|------------|--------------------------------------------------|
| HTTP/1.0    | TCP        | 기본적으로 요청마다 연결을 새로 열고 닫음 (비지속 연결) |
| HTTP/1.1    | TCP        | 기본적으로 지속 연결 사용 |
| HTTP/2.0    | TCP        | 다중 요청 동시 처리(멀티플렉싱) 지원, 성능 향상 |
| HTTP/3.0    | UDP        | QUIC 프로토콜 기반, 지연 최소화 및 연결 복원 기능 강화 |

| 항목         | TCP (Transmission Control Protocol)           | UDP (User Datagram Protocol)            |
|--------------|------------------------------------------------|------------------------------------------|
| 연결 방식     | 연결 지향 (Connection-oriented)               | 비연결 지향 (Connectionless)             |
| 신뢰성        | 보장 (재전송, 순서 보장)                      | 보장하지 않음 (손실/순서 미보장)         |
| 속도          | 상대적으로 느림                               | 빠름                                     |
| 오버헤드      | 큼 (3-way 핸드셰이크 등 제어 필요)             | 작음 (제어 정보 거의 없음)              |
| 패킷 순서     | 순서 보장                                     | 순서 보장 안 됨                          |
| 흐름 제어     | 있음                                           | 없음                                     |
| 혼잡 제어     | 있음                                           | 없음                                     |
| 용도 예시     | HTTP, HTTPS, FTP, SSH, 이메일 등               | 영상 스트리밍, VoIP, 온라인 게임, DNS 등 |


### HTTP 메시지 구조
<img width="739" alt="스크린샷 2025-05-13 오후 9 56 01" src="https://github.com/user-attachments/assets/9cc4f429-b099-45ce-8126-2bba22f1a7c7" />

시작 라인으로 HTTP 메시지가 요청 메시지인지 응답메시지인지 구분할 수 있습니다.<br>
시작 라인은 요청 메시지일 경우에는 요청 라인이 있고, 응답 메시지일 경우에는 상태라인이 있습니다.


## 3. HTTP 메서드와 상태 코드
### HTTP 메서드
<img width="568" alt="스크린샷 2025-05-13 오후 9 58 15" src="https://github.com/user-attachments/assets/fa3350e2-a49b-4e92-91c5-1172a1699e80" />

(1) GET & HEAD
- GET : 자원을 조회하는 용도의 메서드입니다. <br> 웹 브라우저를 통해 여러 웹 사이트의 자원을 조회하는 것은 모두 해당 웹 사이트에 GET 요청을 보내는 것과 같습니다.
- HEAD : 응답 메시지에 메시지 본문이 포함되지 않는다는 점을 제외하고는 GET과 동일합니다.

(2) POST
: 서버로 하여금 특정 작업을 처리하도록 요청하는 용도로 사용되는 메서드입니다.<br>
많은 경우 클라이언트가 서버에 새로운 자원을 생성하고자 할 때 사용됩니다.

(3) PUT 과 PATCH
```

{
  "id": 123,
  "name": "홍길동",
  "email": "gildong@example.com",
  "age": 30
}

PUT /users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "id": 123,
  "name": "홍길순",
  "email": "abcd@example.com",
  "age": 25
}


PATCH /users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "age": 25
}

```
- PUT : 덮어쓰기를 요청하는 메서드입니다.
- PATCH : 부분적 수정을 요청하는 메서드입니다.

(4) DELETE 
: 특정 자원의 삭제를 요청하는 메서드입니다.

### HTTP 상태코드
<img width="712" alt="스크린샷 2025-05-13 오후 10 02 26" src="https://github.com/user-attachments/assets/35835cf2-1f54-4a7e-b44a-1bd624b533fa" />

(1) 200번대: 성공 상태 코드 
- 200 (OK) : 요청이 성공했음
- 201 (Created) : 요청이 성공했으며, 새로운 자원이 생성되었음
- 202 (Accepted) : 요청을 잘 받았으나, 아직 요청한 작업을 끝내지 않았음
- 204 (No Content) : 요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음

(2) 300번대 : 리다이렉션 상태 코드<br>
리다이렉션(redirection : 클라이언트가 요청한 자우너이 다른 곳에 있을 때, 다른 곳으로 요청을 이동시키는 것을 의미합니다.<br>
- 301 (Moved Permanetly) : 영구적 리다이렉션 - 재요청 메서드가 변경될 수 있음
- 308 (Permanent Redirect) : 영구적 리다이렉션 - 재요청 메서드가 변경되지 않음
- 302 (Found) : 일시적 리다이렉션 - 재요청 메서드가 변경될 수 있음
- 303 (See Other) : 일시적 리다이렉션 - 재요청 메서드가 GET으로 변경됨
- 307 (Temporary Redirect) : 일시적 리다이렉션 - 재요청 메서드가 변경되지 않음
- 304 (Not Modified) : 캐시 - 자원이 변경되지 않음

영구적 리다이렉션 : 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것을 의미합니다.<br>
자원의 위치가 영구적으로 변경되었고, 기존 URL에 요청 메시지를 보내면 항상 새로운 URL로 리다이렉트 됩니다.

일시적 리다이렉션 : 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 사용됩니다.<br>
어떤 URL에 대해 일시적인 리다이렉션 관련 상태 코드를 응답 받았을 경우에는 영구적인 리다이렉션과는 달리 여전히 요청을 보낸 기존의 URL을 기억해야 합니다.

(3) 400번대: 클라이언트 에러 상태 코드
- 400 (Bad Request) : 요청 메시지의 내용이나 형식 자체에 문제가 있음
- 401 (Unauthorized) : 요청한 자원에 대한 유효한 인증이 없음 -> 인증
- 403 (Forbidden) : 요청이 서버에 의해 거부됨 (자원에 대한 접근 권한이 충분하지 않음) -> 인가
- 405 (Method Not Allowed) : 존재는 하지만, 해당 메서드가 허용되지 않음 (예: GET만 허용하는데 POST 보냄)

(4) 500번대 : 서버 에러 상태 코드 
- 500 (Internal Server Error) : 요청을 처리할 수 없음
- 502 (Bad Gateway) : 중간 서버의 통신 오류


## 3. HTTP 주요 헤더
### 요청 메시지에서 주로 활용되는 HTTP 헤더
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language: ko-KR,ko;q=0.9
Referrer: https://www.google.com/
Connection: keep-alive
```
(1) Host : 요청을 보낼 호스트가 명시되는 헤더입니다.<br>
(2) User-Agent : 요청 메시지를 보낸 클라이언트의 프로그램과 관련된 정보가 명시됩니다.<br>
(3) Referrer : 클라이언트가 요청을 보낼 때 머무르던 URL를 명시합니다.
 
### 응답 메시지에서 주로 활용되는 HTTP 헤더
```
HTTP/1.1 200 OK
Date: Tue, 13 May 2025 12:00:00 GMT
Server: Apache/2.4.41 (Unix)
Content-Type: text/html; charset=UTF-8
Content-Length: 3056
Connection: keep-alive
Content-Language: ko
```
(1) Server : 응답 메시지를 보내는 서버 호스트와 관련된 정보가 명시됩니다.<br>
(2) Allow : 처리 가능한 HTTP 헤더 목록을 알리기 위해 사용됩니다.<br>
`Allow: POST, OPTIONS`<br>
(3) Location : 클라이언트에게 자원의 위치를 알려주기 위해 사용됩니다. 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 사용됩니다.

### 요청과 응답 메시지 모두에서 활용되는 HTTP 헤더

(1) Data : 메시지가 생성된 날짜와 시각에 대한 정보를 담은 헤더입니다.<br>
(2) Content-Length : 메시지 본문의 바이트 단위 크기를 의미합니다.<br>
(3) Content-Type, Content-Language, Content-Encoding : 메시지 본문이 어떻게 표현되었는지와 관련된 헤더입니다.
- Content-Type	전송되는 콘텐츠의 미디어 타입 (예: application/json, text/html)
- Content-Language	콘텐츠의 언어 정보 (예: ko, en)
- Content-Encoding	콘텐츠 인코딩 방식 (예: gzip, deflate)

(4) Connection : 메시지를 송신하는 호스트가 어떠한 방식의 연결을 원하는지 명시하는 헤더입니다.



